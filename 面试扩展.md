### WEB worker



### 前端安全问题？

**只允许输入合法的值，其它值一概过滤掉。**

**前端安全**:XSS漏洞和CSRF漏洞;

**后端安全**:SQL注入漏洞;权限控制漏洞;SESSION和cookie;IP地址;验证码;

```javascript
//使用JavaScript来检测页面是否是当前打开页面的最外层，如果不是，将最外层的地址换成本页面的地址，实现方法很简单，如下：
if (top != self) {top.location.replace(self.location.href); }  
```

#### sql注入原理

就是通过把`SQL`命令插入到`Web`表单递交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令。

总的来说有以下几点：

```
1.永远不要信任用户的输入，要对用户的输入进行校验，可以通过正则表达式，或限制长度，对单引号和双"-"进行转换等。
2.永远不要使用动态拼装SQL，可以使用参数化的SQL或者直接使用存储过程进行数据查询存取。
3.永远不要使用管理员权限的数据库连接，为每个应用使用单独的权限有限的数据库连接。
4.不要把机密信息明文存放，请加密或者hash掉密码和敏感的信息。
5.所有 SQL 语句都使用参数化查询（推荐）或对参数进行 escape（不推荐）
```

#### XSS原理及防范

`Xss(cross-site scripting)`攻击指的是攻击者往Web页面里插入恶意`html`标签或者`javascript`代码。比如：攻击者在论坛中放一个 看似安全的链接，骗取用户点击后，窃取cookie中的用户私密信息；或者攻击者在论坛中加一个恶意表单， 当用户提交表单的时候，却把信息传送到攻击者的服务器中，而不是用户原本以为的信任站点。

常见xss攻击

```html
<img scr=1 onerror=alert('xss')>当找不到图片名为1的文件时，执行alert('xss')
<a href=javascrip:alert('xss')>s</a> 点击s时运行alert('xss')
<iframe src=javascript:alert('xss');height=0 width=0 /><iframe>利用iframe的scr来弹窗
<img src="1" onerror=eval("\x61\x6c\x65\x72\x74\x28\x27\x78\x73\x73\x27\x29")></img>过滤了alert来执行弹窗

```



#### XSS防范方法

1. 代码里对用户输入的地方和变量都需要仔细检查长度和对`”<”,”>”,”;”,”’”`等字符做过滤；其次任何内容写到页面之前都必须加以`html encode`，避免不小心把`html tag` 弄出来。这一个层面做好，至少可以堵住超过一半的`XSS` 攻击。 
2. JavaScript中有三个可以对字符串编码的函数，分别是： escape,encodeURI,encodeURIComponent，相应3个解码函数：unescape,decodeURI,decodeURIComponent 。
3. 避免直接在`cookie` 中泄露用户隐私，例如`email`、密码等等。 3.通过使cookie 和系统ip 绑定来降低`cookie` 泄露后的危险。这样攻击者得到的cookie 没有实际价值，不可能拿来重放。 
4. 尽量采用POST 而非GET 提交表单
5. ​

#### XSS与CSRF有什么区别吗？

`XSS`是获取信息，不需要提前知道其他用户页面的代码和数据包。`CSRF`是代替用户完成指定的动作，需要知道其他用户页面的代码和数据包。

要完成一次CSRF攻击，受害者必须依次完成两个步骤：

　　1.登录受信任网站A，并在本地生成Cookie。 　　2.在不登出A的情况下，访问危险网站B。

#### CSRF的防御

1.服务端的CSRF方式方法很多样，但总的思想都是一致的，就是在客户端页面增加伪随机数。给所有请求加上 token 检查。token 一般是随机字符串，只需确保其不可预测性即可。token 可以在 QueryString、POST body 甚至是 Custom Header 里，但千万不能在 Cookies 里。 2.使用验证码 3.检查 `referer` （请注意，这往往不能防御来自网站自身的 CSRF 攻击，如用户评论中的 `<img>` 就是一个常见触发点）

**权限控制漏洞**

所有地方都要进行权限检查（如是否已登录、当前用户是否有足够权限、该项是否可修改等），总之，不要相信任何来自用户的数据，URL 当然也是

**SESSION 与 COOKIE**

Session 和 Cookie 是两种用于存储用户当前状态的工具。某些开发者不了解 Session 与 Cookie 的区别，误用或者混用，导致敏感信息泄露或者信息篡改。

Cookie 存储在浏览器上，用户可以查看和修改 Cookie。
Session 是存储在服务端的数据，一般来说安全可靠；大多数 Session 都是基于 Cookie 实现的（在 Cookie 中存储一串 SESSION_ID，在服务器上存储该 SESSION_ID 对应的内容）。

**IP 地址**

首先，用户的 IP 地址一般存储在 `REMOTE_ADDR` 中，这是唯一的可信的 IP 地址数据（视不同语言而定）。然后某些代理服务器，会将用户的真实 IP 地址附加在 header 的 `VIA` 或 `X_FORWARDED_FOR` 中（因为`REMOTE_ADDR` 是代理服务器自身的 IP）。所以，要获取用户 IP 地址，一般做法是，判断是否存在 `VIA` 或者 `X_FORWARDED_FOR` 头，如果存在，则使用它们，如果不存在则使用 `REMOTE_ADDR`。这也是网上大多数所谓教程提供的方法。

这就产生问题了，`X_FORWARDED_FOR` 或 `VIA` 是 HTTP Header，换句话说，它们是可以被伪造的。例如，在投票中，如果采信了 `X_FORWARDED_FOR`，往往意味着被刷票。

解决方法：

只使用 `REMOTE_ADDR` 作为获取 IP 的手段。

**验证码**

验证码里常见的问题有：非一次性、容易被识别。

非一次性指的是，同一个验证码可以一直被用下去。一般来说，每进行一次验证码校对（无论正确与否），都应该强制更换或清除 Session 中的验证码。

关于识别问题，在当前科技水平下，不加噪点不加扭曲的验证码几乎是 100% 可识别的。所以大家自己看着办吧…

### 同源策略

[博客详述](http://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html) 

1. **cookie:**

   A网页是`http://w1.example.com/a.html`，B网页是`http://w2.example.com/b.html`，那么只要设置相同的`document.domain`，两个网页就可以共享Cookie。`document.domain = 'example.com';`注意，这种方法只适用于 Cookie 和 iframe 窗口，LocalStorage 和 IndexDB 无法通过这种方法.

   另外，服务器也可以在设置Cookie的时候，指定Cookie的所属域名为一级域名，比如`.example.com`;二级域名和三级域名不用做任何设置，都可以读取这个Cookie。

   ```javascript
   Set-Cookie: key=value; domain=.example.com; path=/
   ```

2. 浏览器窗口有`window.name`属性。这个属性的最大特点是，无论是否同源，只要在同一个窗口里，前一个网页设置了这个属性，后一个网页可以读取它。

3. HTML5为了解决这个问题，引入了一个全新的API：跨文档通信 API（Cross-document messaging）。

   这个API为`window`对象新增了一个`window.postMessage`方法，允许跨窗口通信，不论这两个窗口是否同源。

   举例来说，父窗口`http://aaa.com`向子窗口`http://bbb.com`发消息，调用`postMessage`方法就可以了。