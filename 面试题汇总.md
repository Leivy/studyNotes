# 面试题汇总

### js计算相关

1. html中有且仅有一个script标签,script标签内有以下代码,请写出以下代码输出的值;

```javascript
var a=1;
  function test() {
    console.log(a);
    try{
      a(3);
      A();
    }catch(e){
      a=2;
    }
    function a(b) {
      a=b;
    }
    console.log(++a);
  }
  test();//function a(b) {a=b;}和3
  console.log(a);//1
```

2. CSS偏移响应鼠标点击操作

   ```css
   /*直接在css里响应鼠标操作*/
   table { background-color:#000000; cursor:hand; width:100%; } 
   td { 
   /*设置onmouseover事件*/ 
   onmouseover: expression(onmouseover=function (){this.style.borderColor ='blue';this.style.color='red';this.style.backgroundColor ='yellow'}); 
   /*设置onmouseout事件*/ 
   onmouseout: expression(onmouseout=function (){this.style.borderColor='';this.style.color='';this.style.backgroundColor =''}); 
   background-color:#ffffff; 
   } 

   /*控制表格隔行变色: */
   <style type="text/css"> 
   tr {background-color:expression((this.sectionRowIndex%2==0)?"#E1F1F1":"#F0F0F0")} 

   ```

   ​

3. **实体标签Etag和最后修改时间Last-modified**

```javascript

```



2. 请写出至少三种跨域请求的解决方法.

   ```reStructuredText
   解决办法：

   1、JSONP：

   使用方式就不赘述了，但是要注意JSONP只支持GET请求，不支持POST请求。

   2、代理：

   例如www.123.com/index.html需要调用www.456.com/server.php，可以写一个接口www.123.com/server.php，由这个接口在后端去调用www.456.com/server.php并拿到返回值，然后再返回给index.html，这就是一个代理的模式。相当于绕过了浏览器端，自然就不存在跨域问题。

   3、PHP端修改header（XHR2方式）

   在php接口脚本中加入以下两句即可：
   header('Access-Control-Allow-Origin:*');//允许所有来源访问
   header('Access-Control-Allow-Method:POST,GET');//允许访问的方式
   ```

   ​

3. 斐波那契数列: 请用递归求解f(20),并写出解法的时间复杂度(注意处理边界)

   ```javascript
   f(1)=1;f(2)=1;
   f(n)=f(n-1)+f(n-2);n>2

   //解法:
   ```

   ![](image/Image 111.png)

4. 请用2种以上方式实现如下功能:每隔1秒依次输出0,1,2...n(至少包含一种ES6的异步实现);

   ```javascript

   ```

   ​

5. 某段dom结构如下:在该dom结构中,li在列表的下标分别是0,1,2,3,4.请分别为每个li添加点击事件,输出响应的下标,注意:使用原生的js,且只能添加事件不能添加属性.

   ```html
   <ul id="list">
     <li>qw</li>
     <li>er</li>
     <li>ty</li>
     <li>ui</li>
     <li>ou</li>
   </ul>
   ```

6. 假设有上题相同的dom结构,通过调用outer方法,把list子元素传入到children,代码如下:请在outer函数内添加代码,把获取到的子元素列表,通过apply方式来调用inner,使得inner方法输出值为true;注意浏览器兼容性问题.

   ```javascript
   function outer(){
     
   }
   function inner(){
     console.log(arguments[0].innerHTML.match(/\s+/)[0]=='qw');
   }
   outer(document.getElementById('list').children);
   ```

7. ```javascript
   var a=10;
           var foo = {
               a: 20,
               bar: function(){
                   var a = 30;
                   console.log(this);
                   return this.a;
               }
           }

           console.log(
               foo.bar(),//20
               (foo.bar)(),//20
               (foo.bar = foo.bar)(),//10
               (foo.bar,foo.bar)()//10
           );
           //(foo.bar = foo.bar)和(foo.bar,foo.bar)是全局函数,this指向Window
   ```

8. ​

   #知识点总结

   ##### Function.caller

   caller是javascript函数的一个属性，它指向调用当前函数的函数，如果函数是在全局范围内调用的话，那么caller的值为null。

   ##### arguments.callee

   arguments是函数内部中一个特殊的对象，callee是arguments的属性之一， 他指向拥有该arguments的函数对象。在某些不方便暴露函数名的情况下， 可以用arguments.callee代替函数名。但是在严格模式下无法访问.在严格模式（“use strict;”）下访问arguments.callee会抛出 TypeError: 'caller', 'callee', and 'arguments' properties may not be accessed on strict mode functions or the arguments objects for calls to them 错误,

   更高级的写法是,用命名函数表达式来创建递归函数:性能优于arguments.callee.

   ```javascript
   var factorial = (function foo(n) {
       if(n<=1) {
           return 1;
       } else {
           return n*foo(n-1); //仅函数内部可访问foo
       }
   });
   foo(6); //ReferenceError: foo is not defined
   ```

   **arguments.caller没啥用,已被废弃;**

#

1. Ubuntu（友帮拓、优般图、乌班图）是一个以桌面应用为主的开源GNU/Linux操作系统，Ubuntu 是基于Debian GNU/Linux，支持x86、amd64（即x64）和ppc架构，由全球化的专业开发团队（Canonical Ltd）打造的。

2. ```
   构造函数没有参数的情况,括号可以省略
   ```

3. jquery提供了一个`serialize()`方法序列化表单

4. toFixed() 方法可把 Number 四舍五入为指定小数位数的数字。

5. 抽象语法树（Abstract Syntax Tree）也称为AST语法树，指的是源代码语法所对应的树状结构。也就是说，对于一种具体编程语言下的源代码，通过构建语法树的形式将源代码中的语句映射到树中的每一个节点上。 

6. 回调函数:

   1. 你到一个商店买东西，刚好你要的东西没有货，于是你在店员那里留下了你的电话，过了几天店里有货了，店员就打了你的电话，然后你接到电话后就到店里去取了货。在这个例子里，你的电话号码就叫回调函数，你把电话留给店员就叫登记回调函数，店里后来有货了叫做触发了回调关联的事件，店员给你打电话叫做调用回调函数，你到店里去取货叫做响应回调事件。回答完毕。

   ![](image/callback.jpg)


###同步调用,回调,异步调用:

​	**同步调用**是一种阻塞式调用，也是我们在写程序中经常使用的；

​	**回调**是一种双向的调用模式；

​	**异步调用**是一种类似消息或事件的机制，解决了同步阻塞的问题。

​	**异步回调典型例子:**

​	提问者A有个问题"1+1=?"，于是A打电话给回答者B，B说他现在很忙，忙完了才能给他想答案，A心想我不能这么一直等着把，于是说：“那咱们约定好，B你想出答案了以打电话的形式告诉我”，挂了电话A也去忙他自己的事了，过了一会B想出答案按A约定好的方式打电话告诉了B答案。

```javascript
//回调时最好保证函数引用或者函数表达式
(callback && typeof(callback) === "function") && callback();
```

### 线程浅析

[博客详解](http://www.cnblogs.com/architects/p/4390671.html)

[图片示例](http://blog.csdn.net/u011643473/article/details/43192083)

浏览器内核实现的基本三个线程--->js引擎线程（用于处理JS）、GUI渲染线程（用于页面渲染）、浏览器事件触发线程（用于控制交互）。除此以外,也有一些执行完就终止的线程,如Http请求线程,这些异步线程都会产生不同的异步事件,

**因为JS可以操作DOM元素，进而会影响到GUI的渲染结果，因此JS引擎线程与GUI渲染线程是互斥的。在JavaScript引擎运行脚本期间,浏览器渲染线程都是处于挂起状态的,也就是说被”冻结”了.**

JS引擎是**基于事件驱动**，采用的是**单线程**运行机制。即JS引擎会只会顺序的从任务列表中取任务，并执行。

![](image/gui线程.png)

```html
//html结构:	
	<div id="output"></div>
    <button onclick="updateSync()">Run Sync</button>
    <button onclick="updateAsync()">Run Async</button>
<script>
//同步 -->js引擎运行时页面渲染线程是冻结状态,所以直接显示最终结果
        function updateSync() {
            for (var i = 0; i < 1000; i++) {              
                document.getElementById('output').innerHTML = i;
            }
        }
//异步 --->如上图
        function updateAsync() {
            var i = 0;

            function updateLater() {
                document.getElementById('output').innerHTML = (i++);
                if (i < 1000) {
                    setTimeout(updateLater, 0);
                }
            }

            updateLater();
        }
  </script>
```



相关面试题:

```javascript
var t = true;

window.setTimeout(function (){//异步,等待主线程代码走完才会处理这个
    t = false;
},1000);

while (t){};//死循环,所以不会执行到后面的代码

alert('end');
```

补充:

```javascript
requestFileSystem
```



###请列出n种前端性能优化方案.

CDN加速.反向代理 http://blog.csdn.net/mahoking/article/details/51472697  如下是浏览器访问优化:

```reStructuredText
1、减少http请求，合理设置 HTTP缓存
	在服务器端，每个http都需要启动独立的线程去处理。减少http请求的数目可有效提高访问性能。减少http的主要手段是合并CSS、合并JavaScript、合并图片。
2、使用浏览器缓存
	通过设置http头中的cache-control和expires的属性，可设定浏览器缓存。在某些时候，静态资源文件变化需要及时应用到客户端浏览器，这种情况，可通过改变文件名实现，生成一个新的js文件并更新HTML文件中的引用。
3、启用压缩
	在服务器端对文件进行压缩，在浏览器端对文件解压缩，可有效减少通信传输的数据量。
4、CSS Sprites
	合并 CSS图片，制作一个精灵图,减少请求数的又一个好办法。
5、LazyLoad Images
6、CSS放在页面最上部，javascript放在页面最下面
7、异步请求Callback（就是将一些行为样式提取出来，慢慢的加载信息的内容）
8、减少cookie传输
9、Javascript代码优化
	1.DOM元素操作
	2.慎用 with　
		with(obj){ p = 1}; 代码块的行为实际上是修改了代码块中的执行环境 ，将obj放在了其作用域链的最前端，在 with代码块中访问非局部变量是都是先从 obj上开始查找，如果没有再依次按作用域链向上查找，因此使用 with相当于增加了作用域链长度。而每次查找作用域链都是要消耗时间的，过长的作用域链会导致查找性能下降。 
　　因此，除非你能肯定在 with代码中只访问 obj中的属性，否则慎用 with，替代的可以使用局部变量缓存需要访问的属性。
　　3.避免使用 eval和 Function
　　	每次 eval 或Function 构造函数作用于字符串表示的源代码时，脚本引擎都需要将源代码转换成可执行代码。这是很消耗资源的操作 —— 通常比简单的函数调用慢 100倍以上。 
　　eval 函数效率特别低，由于事先无法知晓传给 eval 的字符串中的内容，eval在其上下文中解释要处理的代码，也就是说编译器无法优化上下文，因此只能有浏览器在运行时解释代码。这对性能影响很大。 
　　Function 构造函数比 eval略好，因为使用此代码不会影响周围代码 ;但其速度仍很慢。 
　　此外，使用 eval和 Function也不利于Javascript 压缩工具执行压缩。
　　4.减少作用域链查找
　　	前文谈到了作用域链查找问题，这一点在循环中是尤其需要注意的问题。如果在循环中需要访问非本作用域下的变量时请在遍历之前用局部变量缓存该变量，并在遍历结束后再重写那个变量，这一点对全局变量尤其重要，因为全局变量处于作用域链的最顶端，访问时的查找次数是最多的。 此外，要减少作用域链查找还应该减少闭包的使用。
　　5. 数据访问
　　	Javascript中的数据访问包括直接量 (字符串、正则表达式 )、变量、对象属性以及数组，其中对直接量和局部变量的访问是最快的，对对象属性以及数组的访问需要更大的开销。当出现以下情况时，建议将数据放入局部变量： 
　　a. 对任何对象属性的访问超过 1次 
　　b. 对任何数组成员的访问次数超过 1次 
　　另外，还应当尽可能的减少对对象以及数组深度查找。
　	6.字符串拼接
　		在 Javascript中使用”+”号来拼接字符串效率是比较低的，因为每次运行都会开辟新的内存并生成新的字符串变量，然后将拼接结果赋值给新变量。与之相比更为高效的做法是使用数组的 join方法，即将需要拼接的字符串放在数组中最后调用其 join方法得到结果。不过由于使用数组也有一定的开销，因此当需要拼接的字符串较多的时候可以考虑用此方法。
　	7.CSS选择符优化
```



###web APP vs  Native APP

**web APP优点:**

1. 跨平台：所有系统都能运行
2. 免安装：打开浏览器，就能使用
3. 快速部署：升级只需在服务器更新代码
4. 超链接：可以与其他网站互连，可以被搜索引擎检索

**web APP 短板:**

1. Web基于DOM，而DOM很慢。--->浏览器打开网页时，需要解析文档，在内存中生成DOM结构，如果遇到复杂的文档，这个过程是很慢的。
2. DOM拖慢JavaScript。 --->所有的DOM操作都是同步的，会堵塞浏览器。JavaScript操作DOM时，必须等前一个操作结束，才能执行后一个操作。只要一个操作有卡顿，整个网页就会短暂失去响应。浏览器重绘网页的频率是60FPS（即16毫秒/帧），JavaScript做不到在16毫秒内完成DOM操作，因此产生了跳帧。用户体验上的不流畅、不连贯就源于此。
3. 网页是单线程的.--->现在的浏览器对于每个网页，只用一个线程处理。所有工作都在这一个线程上完成，包括布局、渲染、JavaScript执行、图像解码等等
4. 网页没有硬件加速。--->网页都是由CPU处理的，没用GPU进行图形加速。

**未来的路:**

1. 多线程浏览器。--->每个网页应该由多个线程进行处理，主线程只负责布局和渲染，而且应该在16毫秒内完成，JavaScript由worker线程执行，这样就不会发生堵塞了。
2. DOM的异步操作。-->JavaScript对DOM的操作不再是同步的，而是触发后，交给Event Loop机制进行监听。
3. 非DOM方案。--->浏览器不再将网页处理成DOM结构，而是变为其他结构。



### React

React的核心机制之一就是可以在内存中创建虚拟的DOM元素。React利用虚拟DOM来减少对实际DOM的操作从而提升性能。 

### JSX

JSX就是Javascript和XML结合的一种格式。React发明了JSX，利用HTML语法来创建虚拟DOM。当遇到<，JSX就当HTML解析，遇到{就当JavaScript解析。

### 微信小程序

```javascript

```



### HTML标签语义化

1. **语义化理解--->**根据内容的结构化（内容语义化），选择合适的标签（代码语义化）**便于开发者阅读和写出更优雅的代码**的同时**让浏览器的爬虫和机器很好地解析**。
2. 语义化的意义--->
   1. 为了在没有CSS的情况下，页面也能呈现出很好地内容结构、代码结构:为了裸奔时好看；
   2. 用户体验：例如title、alt用于解释名词或解释图片信息、label标签的活用；
   3. 有利于[SEO](http://baike.baidu.com/view/1047.htm)：和搜索引擎建立良好沟通，有助于爬虫抓取更多的有效信息：[爬虫](http://baike.baidu.com/view/998403.htm)依赖于标签来确定上下文和各个关键字的权重；
   4. 方便其他设备解析（如屏幕阅读器、盲人阅读器、移动设备）以意义的方式来渲染网页；
   5. 便于团队开发和维护，语义化更具可读性，是下一步吧网页的重要动向，遵循W3C标准的团队都遵循这个标准，可以减少差异化。
3. **写HTML代码时应注意什么？**
   1. 尽可能少的使用无语义的标签div和span；
   2. 在语义不明显时，既可以使用div或者p时，尽量用p, 因为p在默认情况下有上下间距，对兼容特殊终端有利；
   3. 不要使用纯样式标签，如：b、font、u等，改用css设置。
   4. 需要强调的文本，可以包含在strong或者em标签中（浏览器预设样式，能用CSS指定就不用他们），strong默认样式是加粗（不要用b），em是斜体（不用i）；
   5. 使用表格时，标题要用caption，表头用thead，主体部分用tbody包围，尾部用tfoot包围。表头和一般单元格要区分开，表头用th，单元格用td；
   6. 表单域要用fieldset标签包起来，并用legend标签说明表单的用途；
   7. 每个input标签对应的说明文本都需要使用label标签，并且通过为input设置id属性，在lable标签中设置for=someld来让说明文本和相对应的input关联起来。
4. **HTML5新增了哪些语义标签，详述之。**
   1. [html5新增语义标签](http://www.html5jscss.com/html5-semantics-section.html)
   2. ![](image/html5-layout.jpg)